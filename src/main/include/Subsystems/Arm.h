// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef ARM_H
#define ARM_H
#include "frc/commands/Subsystem.h"
#include "frc/WPILib.h"
#include "ctre/Phoenix.h"


#define ARM_TICS_PER_ROTATION (0.026041667/1024.0)
#define ARM_TICS_PER_DEGREE (ARM_TICS_PER_ROTATION*360.0) // TODO

/*
#define ARM_ERROR_MARGIN_TICS 100
#define ARM_PEAK_FORWARD 0.85
#define ARM_PEAK_REVERSE -0.15
#define ARM_PID_P_VALUE 1.1				//Old Values for 4 springs
#define ARM_PID_I_VALUE 0.005
#define ARM_PID_D_VALUE 0.1
#define ARM_TICS_IN_RANGE 5000
*/

#define ARM_ERROR_MARGIN_TICS 100
#define ARM_PEAK_FORWARD 0.70
#define ARM_PEAK_FORWARD_UP_BALL 0.80 // only when starting in down position with ball, need to overcome friction
#define ARM_PEAK_REVERSE -0.25
#define ARM_PID_P_VALUE 0.75				//New Values for 5 springs

#define ARM_PID_I_VALUE 0.0025
#define ARM_PID_D_VALUE 0.05
#define ARM_TICS_IN_RANGE 5000

#define ARM_MIN_ARM_TICS_FOR_INTAKE_UP 2000
#define ARM_MIN_TICS_AT_LOW_POSITION 100
//#define ARM_MIN_INTAKE_TICS_FOR_ARM -1.0*((INTAKE_POSITION_DOWN-1) * INTAKE_TICS_PER_DEGREE) CHANGED ON 3-1-917am
#define ARM_MIN_INTAKE_TICS_FOR_ARM -5000.0

#define ARM_POSITION_DOWN   0
#define ARM_POSITION_LOAD  (900 *  ARM_TICS_PER_DEGREE)
#define ARM_POSITION_LOW_BALL  (1350 *  ARM_TICS_PER_DEGREE)
#define ARM_POSITION_MID_BALL  (3150 * ARM_TICS_PER_DEGREE)
#define ARM_POSITION_HIGH_BALL (5125 * ARM_TICS_PER_DEGREE)
#define ARM_POSITION_CARGO_BALL (2250 *  ARM_TICS_PER_DEGREE)
#define ARM_POSITION_LOW_HATCH  ARM_POSITION_LOAD
#define ARM_POSITION_MID_HATCH  (2650 * ARM_TICS_PER_DEGREE)
#define ARM_POSITION_HIGH_HATCH (4700 * ARM_TICS_PER_DEGREE)


#define INTAKE_ROTATION_PER_TIC (0.3125/1024.0)
#define INTAKE_DEGREES_PER_TIC (INTAKE_ROTATION_PER_TIC*360.0)
#define INTAKE_TICS_PER_ROTATION 13107.2
#define INTAKE_TICS_PER_DEGREE 36.40888889
#define INTAKE_GEAR_RATIO 38.4
#define INTAKE_MOTOR_REVS_PER_DEGREE (360.0 / INTAKE_GEAR_RATIO)
#define INTAKE_MAX_UP_SPEED 0.40
#define INTAKE_MAX_DOWN_SPEED -0.20
#define INTAKE_TICS_RANGE 5200
#define INTAKE_ERROR_MARGIN_TICS 50
#define INTAKE_PID_P_VALUE 1.0
#define INTAKE_PID_I_VALUE 0.0001
#define INTAKE_PID_D_VALUE 0.1
#define INTAKE_POSITION_UP   0.0
#define INTAKE_POSITION_OUT 90.0
#define INTAKE_POSITION_DOWN 143.0

#define INTAKE_IN_SPEED_SCALE 0.6
#define INTAKE_OUT_SPEED_SCALE -1.0
#define CLAW_IN_SPEED_SCALE -1.0
#define CLAW_OUT_SPEED_SCALE 1.0

class Arm: public frc::Subsystem {
private:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<WPI_TalonSRX> talonSRX_A1;
	std::shared_ptr<WPI_TalonSRX> talonIntake;
	std::shared_ptr<WPI_VictorSPX> victorSPX_A1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	double _armP;
	double _armI;
	double _armD;
	double _armF;
	double _intakeP;
	double _intakeI;
	double _intakeD;
	double _intakeF;

	bool _intakePIDActive;
	bool _intakeAtPIDPosition;
	double _intakePIDSetPoint;
	double _intakeZeroEncValue;
	double _intakeZeroAngle;
	int _intakeEnumSet;
	double _intakePercentOutput;

	bool _armPIDActive;
	bool _armAtPIDPosition;
	int _armPIDSetPoint;
	int _armEnumSetPoint;
	double _armPercentOutput;

	void InitArm();
	void InitIntake();
	void PrintValues();
public:
	Arm();
	void InitDefaultCommand() override;
	void Periodic() override;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	frc::Preferences *prefs;
	enum E_INTAKE_POSITION
	{
		E_INTAKE_UP   = 0,
		E_INTAKE_OUT  = 1,
		E_INTAKE_DOWN = 2,
		E_INTAKE_INVALID
	};

	enum E_ARM_POSITION
	{
		E_ARM_DOWN       = 0,
		E_ARM_LOAD       = 1,
		E_ARM_LOW_HATCH  = 2,
		E_ARM_MID_HATCH  = 3,
		E_ARM_HIGH_HATCH = 4,
		E_ARM_LOW_BALL = 5,
		E_ARM_MID_BALL = 6,
		E_ARM_HIGH_BALL = 7,
		E_ARM_CARGO_BALL  = 8,
		E_ARM_INVALID
	};
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    void ArmPIDSetTestValues(bool def);
	void ArmDrive(double a);
	void RunArm();
	void ResetArmEncoder();
	void ResetIntakeEncoder();
	void SetPIDEnabled(bool state);
	double GetEncoderDistance();
	void SetMotorSpeed(double speed);
	int GetPIDError();
	int GetEncoderAbsolutePosition();
	int GetEncoderAbsoluteRaw();

	double GetArmHeight();
	double GetHeightFromAngle(double angle);
	double GetAngleFromHeight(double height);
	double GetArmAngleFromTics();
	double SetArmPositionWithPID(E_ARM_POSITION p);
	double GetSetPointFromAngle(double angle);
	int    GetEnumSetPoint();
	
	int GetLEDValueForArm();
	void SetPointHere();
	void SetArmAbsoluteHeightWithPid(double in);
	void SetArmWithPID(double in);
	void SetInches(double inches);

	void SetArmMotorSpeed(double speed);
	void SetArmPointHere();
	void HoldArmWithPID();
	void SetIntakePIDPosition(E_INTAKE_POSITION p);
	bool IsIntakeOnFloor();
	bool IsSafeToMoveArm(bool down, double tgtTics);
	bool IsSafeToMoveIntakeUp();
	void   SetArmPIDPosition(E_ARM_POSITION p);
	int    GetArmPIDSettingFromEnum(E_ARM_POSITION p);
	double GetArmAngleFromEnum(E_ARM_POSITION p);
	double GetIntakePIDAngleFromEnum(E_INTAKE_POSITION p);
	void   SetIntakeArmMotor(double s);
	double GetIntakeEncPosition();
	void   SetIntakeSpinMotor(double s);
	double GetIntakeDegreesFromEnc();
	void   SpinIntakeByXbox();
	int    GetArmHeightSetting();
	int    GetIntakeSetting();
};

enum Constants {
	/**
	 * Which PID slot to pull gains from.  Starting 2018, you can choose
	 * from 0,1,2 or 3.  Only the first two (0,1) are visible in web-based configuration.
	 */
	kSlotIdx = 0,

	/* Talon SRX/ Victor SPX will supported multiple (cascaded) PID loops.
	 * For now we just want the primary one.
	 */
	kPIDLoopIdx = 0,

	/*
	 * set to zero to skip waiting for confirmation, set to nonzero to wait
	 * and report to DS if action fails.
	 */
	kTimeoutMs = 30
};

#endif
