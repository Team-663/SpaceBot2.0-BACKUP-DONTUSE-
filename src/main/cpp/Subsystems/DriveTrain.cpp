// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/DriveTrain.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveByJoystick.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveTrain::DriveTrain() : frc::Subsystem("DriveTrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    sparkMX_L1.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    sparkMX_L2.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    scg_1 = std::make_shared<frc::SpeedControllerGroup>(*sparkMX_L1, *sparkMX_L2  );
    sparkMX_R1.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    sparkMX_R2.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    scg_2 = std::make_shared<frc::SpeedControllerGroup>(*sparkMX_R1, *sparkMX_R2  );
    robotDrive.reset(new frc::DifferentialDrive(*scg_1, *scg_2));
    pdp.reset(new frc::PowerDistributionPanel(0));
    pigeon.reset(new PigeonIMU(5));
    compressor.reset(new frc::Compressor(12));
    pressureSensor.reset(new frc::AnalogInput(0));
    climbSolenoid.reset(new frc::DoubleSolenoid(12, 2, 3));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    gyroSource = new GyroPID();
    pigeon->SetFusedHeading(0.0, 30);

    rotateOutput = new RotatePID();

    turnPID = new frc::PIDController(TURN_PID_P, TURN_PID_I, TURN_PID_D, TURN_PID_F, *gyroSource, *rotateOutput);
    InitTurnPID();

}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveByJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveTrain::Periodic() {
    // Put code here to be run every loop
    gyroSource->SetHeading(GetGyroBearing());
}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

void DriveTrain::InitTurnPID()
{
    turnPID->SetContinuous(true);
    turnPID->SetInputRange(-180.0, 180.0);
    turnPID->SetOutputRange(-1.0*TURN_MAX_SPEED, TURN_MAX_SPEED);
    turnPID->SetAbsoluteTolerance(TURN_PID_TOLERANCE);
    turnPID->Disable();
}

void DriveTrain::SetTurnPIDEnabled(bool enable)
{
    if (enable)
        turnPID->Enable();
    else
        turnPID->Disable();
}

void DriveTrain::SetTurnPIDSetpoint(double angle)
{
    turnPID->SetSetpoint(angle);
}

bool DriveTrain::TurnPIDOnTarget()
{
    return turnPID->OnTarget();
}

// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveTrain::TankDrive(double l, double r)
{
	robotDrive->TankDrive(-1.0*l, -1.0*r, true);
    //DisplayDrivetrainSensors();
}

void DriveTrain::ArcadeDrive(double speed, double rotation)
{
	robotDrive->ArcadeDrive(-1.0*speed, 1.0*rotation, true);
    //DisplayDrivetrainSensors();
}

void DriveTrain::Stop()
{
	robotDrive->StopMotor();
}

double DriveTrain::GetGyroBearing()
{
    PigeonIMU::FusionStatus *stat = new PigeonIMU::FusionStatus();
	pigeon->GetFusedHeading(*stat);
    return stat->heading;
}

void DriveTrain::RotateRobot(double mag)
{
	if (mag < -1.0)
		mag = -1.0;

	if (mag > 1.0)
		mag = 1.0;

	robotDrive->TankDrive(mag, -1.0*mag, false);
}

// TODO: SAM PUT THE NETWORK TABLE DATA HERE
double DriveTrain::GetVisionTargetOffset()
{
    //return table->GetEntry("Contours");
    //return 0.0;
}

double DriveTrain::GetPDPChannelCurrent(int channel)
{
    double curr = 0.0;
    if (channel <= 15)
        curr = pdp->GetCurrent(curr);

    return curr;
}

double DriveTrain::GetPressure()
{
    double v = pressureSensor->GetVoltage();
    double p = 250 * (v / 5.0) - 25 + PRESSURE_SENSOR_OFFSET;
    return p;
}

void DriveTrain::DisplayDrivetrainSensors()
{

	//frc::SmartDashboard::PutNumber("SparkMXL1CURR", pdp->GetCurrent(15));
	//frc::SmartDashboard::PutNumber("SparkMXL2CURR", pdp->GetCurrent(14));
	//frc::SmartDashboard::PutNumber("SparkMXR1CURR", pdp->GetCurrent(13));
	//frc::SmartDashboard::PutNumber("SparkMXR2CURR", pdp->GetCurrent(12));
    //frc::SmartDashboard::PutNumber("TalonArmCURR", pdp->GetCurrent(4));

    //frc::SmartDashboard::PutNumber("SparkMXL1Pos", L1Encoder->GetPosition());
    //frc::SmartDashboard::PutNumber("SparkMXL2Pos", L2Encoder->GetPosition());
    //frc::SmartDashboard::PutNumber("SparkMXR1Pos", R1Encoder->GetPosition());
    //frc::SmartDashboard::PutNumber("SparkMXR2Pos", R2Encoder->GetPosition());

    frc::SmartDashboard::PutNumber("Gyro", pigeon->GetCompassHeading());

    frc::SmartDashboard::PutNumber("Pressure", GetPressure());


}
