// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Commands/ArmManualControl.h"
#include "Subsystems/Arm.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/IntakeByPID.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Arm::Arm() : frc::Subsystem("Arm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    talonSRX_A1.reset(new WPI_TalonSRX(6));
    
    
    talonIntake.reset(new WPI_TalonSRX(11));
    
    
    victorSPX_A1.reset(new WPI_VictorSPX(8));
    
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    prefs = frc::Preferences::GetInstance();
	_armP = prefs->GetDouble("ArmPID P", ARM_PID_P_VALUE);
	_armI = prefs->GetDouble("ArmPID I", ARM_PID_I_VALUE);
	_armD = prefs->GetDouble("ArmPID D", ARM_PID_D_VALUE);
	_armF = 0.0;
	InitArm();
	_intakeP = prefs->GetDouble("IntPID P", INTAKE_PID_P_VALUE);
	_intakeI = prefs->GetDouble("IntPID I", INTAKE_PID_I_VALUE);
	_intakeD = prefs->GetDouble("IntPID D", INTAKE_PID_D_VALUE);
	_intakeF = 0.0;
	InitIntake();
}

void Arm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new IntakeByPID());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Arm::Periodic() {
    // Put code here to be run every loop
	if (Robot::oi->GetXboxStartR())
	{
		ResetIntakeEncoder();
		
	}

	if (Robot::oi->GetXboxBackL())
	{
		ResetArmEncoder();
	}

	int newEndGameSwitch = Robot::oi->GetEndGameSafetySwitch();
	if (newEndGameSwitch != _endGameSwitched)
	{
		if (newEndGameSwitch)
		{
			talonIntake->ConfigPeakOutputReverse(-1.0, kTimeoutMs);
		}
		else
		{
			talonIntake->ConfigPeakOutputReverse(INTAKE_MAX_DOWN_SPEED, kTimeoutMs);
		}
	}
	_endGameSwitched = newEndGameSwitch;

	if (_intakePIDActive)
	{
		_armPercentOutput = 0.0;
		talonIntake->Set(ControlMode::Position, _intakePIDSetPoint);
	}
	else
	{
		talonIntake->Set(ControlMode::PercentOutput, _armPercentOutput);
	}

	if (_armPIDActive)
	{
		_intakePercentOutput = 0.0;
		talonSRX_A1->Set(ControlMode::Position, _armPIDSetPoint);
	}
	else
	{
		talonSRX_A1->Set(ControlMode::PercentOutput, _intakePercentOutput);
	}

	PrintValues();

}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


void Arm::InitArm()
{
	int absolutePosition = talonSRX_A1->GetSelectedSensorPosition(0) & 0xFFF; /* mask out the bottom12 bits, we don't care about the wrap arounds */
	/* use the low level API to set the quad encoder signal */
	talonSRX_A1->SetSelectedSensorPosition(absolutePosition, kPIDLoopIdx,kTimeoutMs);

	/* choose the sensor and sensor direction */
	talonSRX_A1->ConfigSelectedFeedbackSensor(
			FeedbackDevice::CTRE_MagEncoder_Relative, kPIDLoopIdx,
			kTimeoutMs);
	talonSRX_A1->SetSensorPhase(true);
	talonSRX_A1->ConfigAllowableClosedloopError(0,ARM_ERROR_MARGIN_TICS,kTimeoutMs);

	/* set the peak and nominal outputs, 12V means full */
	talonSRX_A1->ConfigNominalOutputForward(0, kTimeoutMs);
	talonSRX_A1->ConfigNominalOutputReverse(0, kTimeoutMs);
	talonSRX_A1->ConfigPeakOutputForward(ARM_PEAK_FORWARD, kTimeoutMs);
	talonSRX_A1->ConfigPeakOutputReverse(ARM_PEAK_REVERSE, kTimeoutMs);
	/* set closed loop gains in slot0 */
	talonSRX_A1->Config_kP(kPIDLoopIdx, _armP, kTimeoutMs);
	talonSRX_A1->Config_kI(kPIDLoopIdx, _armI, kTimeoutMs);
	talonSRX_A1->Config_kD(kPIDLoopIdx, _armD, kTimeoutMs);
	talonSRX_A1->Config_kF(kPIDLoopIdx, _armF, kTimeoutMs);
	_armPIDSetPoint = GetArmAngleFromTics();
	_armEnumSetPoint = Arm::E_ARM_DOWN;
	_armPIDActive = false;
	_armPercentOutput = 0.0;
	talonSRX_A1->ConfigReverseSoftLimitEnable(false, kTimeoutMs);
	talonSRX_A1->ConfigForwardSoftLimitEnable(false, kTimeoutMs);


	ResetArmEncoder();
}

void Arm::InitIntake()
{
	int absolutePosition2 = talonIntake->GetSelectedSensorPosition(0) & 0xFFF; /* mask out the bottom12 bits, we don't care about the wrap arounds */
	talonIntake->SetSelectedSensorPosition(absolutePosition2, kPIDLoopIdx,kTimeoutMs);

	talonIntake->ConfigSelectedFeedbackSensor(
			FeedbackDevice::CTRE_MagEncoder_Relative, kPIDLoopIdx,
			kTimeoutMs);
	talonIntake->SetSensorPhase(false);
	talonIntake->ConfigAllowableClosedloopError(0,INTAKE_ERROR_MARGIN_TICS,kTimeoutMs);

	talonIntake->ConfigNominalOutputForward(0, kTimeoutMs);
	talonIntake->ConfigNominalOutputReverse(0, kTimeoutMs);
	talonIntake->ConfigPeakOutputForward(INTAKE_MAX_UP_SPEED, kTimeoutMs);
	talonIntake->ConfigPeakOutputReverse(INTAKE_MAX_DOWN_SPEED, kTimeoutMs);
	talonIntake->Config_kP(kPIDLoopIdx, _intakeP, kTimeoutMs);
	talonIntake->Config_kI(kPIDLoopIdx, _intakeI, kTimeoutMs);
	talonIntake->Config_kD(kPIDLoopIdx, _intakeD, kTimeoutMs);
	talonIntake->Config_kF(kPIDLoopIdx, _intakeF, kTimeoutMs);
	talonIntake->ConfigReverseSoftLimitEnable(false, kTimeoutMs);
	talonIntake->ConfigForwardSoftLimitEnable(false, kTimeoutMs);

	_intakePIDActive = false;

	ResetIntakeEncoder();
	_intakePIDSetPoint = 0;
	_intakePercentOutput = 0.0;
}

int Arm::GetEncoderAbsoluteRaw()
{
	return talonSRX_A1->GetSensorCollection().GetPulseWidthPosition();
}

double Arm::GetArmAngleFromTics()
{
	return talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx)*ARM_TICS_PER_DEGREE;
	
}

double Arm::GetSetPointFromAngle(double angle)
{
	return (angle / ARM_TICS_PER_DEGREE);
}

int Arm::GetEnumSetPoint()
{
	return (int)_armEnumSetPoint;
}

double Arm::SetArmPositionWithPID(E_ARM_POSITION p)
{
	double angleTgt = GetArmAngleFromEnum(p);
	double tgtTics = GetArmAngleFromEnum(p) / ARM_TICS_PER_DEGREE;
	double angleCurr = GetArmAngleFromTics();
	bool armSafe = false;

	frc::SmartDashboard::PutNumber("angleTgt", angleTgt);
	frc::SmartDashboard::PutNumber("angleCurr", angleCurr);
	frc::SmartDashboard::PutNumber("angleDelta", angleTgt - angleCurr);
	
	// If request to move up
	if (angleTgt > angleCurr)
	{
		//TODO
		armSafe = IsSafeToMoveArm(false, tgtTics);
		if (armSafe)
		{
			_armPIDActive = true;
			_armPIDSetPoint = GetSetPointFromAngle(angleTgt);
			_armEnumSetPoint = p;
		}
	}
	else if (angleTgt < angleCurr) // move down
	{
		armSafe = IsSafeToMoveArm(true, tgtTics);
		if (armSafe)
		{
			_armPIDActive = true;
			_armPIDSetPoint = GetSetPointFromAngle(angleTgt);
			_armEnumSetPoint = p;
		}
	}
	frc::SmartDashboard::PutBoolean("ArmSAFE", armSafe);
	
	frc::SmartDashboard::PutNumber("Arm Set Angle",angleTgt);
	
	frc::SmartDashboard::PutBoolean("ArmPID_Active", _armPIDActive);
	
}


void Arm::ResetArmEncoder()
{
	talonSRX_A1->GetSensorCollection().SetQuadraturePosition(0, 10);
	talonSRX_A1->GetSensorCollection().SetAnalogPosition(0, 10);
}

void Arm::ResetIntakeEncoder()
{
	talonIntake->GetSensorCollection().SetQuadraturePosition(0, 10);
	talonIntake->GetSensorCollection().SetAnalogPosition(0, 10);
}
int Arm::GetPIDError()
{
	return talonSRX_A1->GetClosedLoopError(0);
}

void Arm::SetArmMotorSpeed(double speed)
{
	_armPIDActive = false;
	//talonSRX_A1->Set(ControlMode::PercentOutput, speed);
	_armPercentOutput = speed;
	// TODO: add safety check before allowing motor to move
}

void Arm::SetIntakePIDPosition(E_INTAKE_POSITION p)
{
	bool intSafe = false;
	if (p < E_INTAKE_INVALID)
	{
		_intakePIDActive = true;

		//int requestedPIDSetting = GetIntakePIDSettingFromEnum(p);
		double requestedEncValue =  -1.0*GetIntakePIDAngleFromEnum(p) * INTAKE_TICS_PER_DEGREE;
		if (p == E_INTAKE_UP)
		{
			intSafe = IsSafeToMoveIntakeUp();
			// Cannot allow intake to move up if the arm is in conflicting posotion
			if (intSafe)
			{
				_intakePIDSetPoint = requestedEncValue;
				_intakeEnumSet = (int)p;
			}
		}
		else
		{
			// always allow intake to be moved to low positions
			_intakePIDSetPoint = requestedEncValue;
			_intakeEnumSet = (int)p;
		}
	}
	frc::SmartDashboard::PutBoolean("intSAFE", intSafe);
}

bool Arm::IsSafeToMoveIntakeUp()
{
	double armTics = talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx);
	if (armTics < ARM_MIN_ARM_TICS_FOR_INTAKE_UP && armTics > ARM_MIN_TICS_AT_LOW_POSITION )
		return false;
	
	return true;
}

bool Arm::IsIntakeOnFloor()
{
	return (talonIntake->GetSelectedSensorPosition(kPIDLoopIdx) < ARM_MIN_INTAKE_TICS_FOR_ARM);
}

bool Arm::IsSafeToMoveArm(bool down, double tgtTics)
{
	double armTics = talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx);
	bool IntakeOnFloor = IsIntakeOnFloor();
	frc::SmartDashboard::PutNumber("ArmSafeTicsc", ARM_MIN_INTAKE_TICS_FOR_ARM);
	frc::SmartDashboard::PutBoolean("ArmDown?", down);
	if  ( IntakeOnFloor || 
		( !down && (armTics > ARM_MIN_ARM_TICS_FOR_INTAKE_UP)))
	{
		return true;
	}
	else
	{
    	return false;
	}
}

double Arm::GetArmAngleFromEnum(E_ARM_POSITION p)
{
	switch (p)
	{
		case E_ARM_DOWN:       return 0.0;
		case E_ARM_LOAD:       return ARM_POSITION_LOAD;
		case E_ARM_LOW_HATCH:  return ARM_POSITION_LOW_HATCH;
		case E_ARM_MID_HATCH:  return ARM_POSITION_MID_HATCH;
		case E_ARM_HIGH_HATCH: return ARM_POSITION_HIGH_HATCH;
		case E_ARM_LOW_BALL:   return ARM_POSITION_LOW_BALL;
		case E_ARM_MID_BALL:   return ARM_POSITION_MID_BALL;
		case E_ARM_HIGH_BALL:  return ARM_POSITION_HIGH_BALL;
		case E_ARM_CARGO_BALL: return ARM_POSITION_CARGO_BALL;
		case E_ARM_INVALID:
		default:
			return 0.0;
	}
}

double Arm::GetIntakePIDAngleFromEnum(E_INTAKE_POSITION p)
{
	switch (p)
	{
		case E_INTAKE_UP:   return INTAKE_POSITION_UP ;
		case E_INTAKE_OUT:  return INTAKE_POSITION_OUT;
		case E_INTAKE_DOWN: return INTAKE_POSITION_DOWN;
		case E_INTAKE_INVALID:
		default:
			return 0;
	}
}

void Arm::SetIntakeArmMotor(double s)
{
	frc::SmartDashboard::PutNumber("IntakeSpeedmanual", s);
	_intakePIDActive = false;
	//talonIntake->Set(ControlMode::PercentOutput, s);
	_intakePercentOutput = s;
}

double Arm::GetIntakeEncPosition()
{
	return talonIntake->GetSelectedSensorPosition(kPIDLoopIdx);
}

void Arm::SetIntakeSpinMotor(double s)
{
	victorSPX_A1->Set(s);
}

double Arm::GetIntakeDegreesFromEnc()
{
	return talonIntake->GetSelectedSensorPosition(kPIDLoopIdx) / INTAKE_TICS_PER_DEGREE;
}

void Arm::SpinIntakeByXbox()
{
	double tl = Robot::oi->GetXboxTriggerLeft() + Robot::oi->getJoyL()->GetRawButton(1);
	double tr = Robot::oi->GetXboxTriggerRight() + Robot::oi->getJoyR()->GetRawButton(1);
	double intakeSpeed = 0.0;
	double clawSpeed = 0.0;
	
	if ( (tl != 0.0) ^ (tr != 0.0) )
	{
		if (tl)
		{
			intakeSpeed = tl * INTAKE_IN_SPEED_SCALE;
			//clawSpeed   = tl * CLAW_IN_SPEED_SCALE;
		}
		else
		{
			//clawSpeed = tr * CLAW_OUT_SPEED_SCALE;
		}
	}

	SetIntakeSpinMotor(intakeSpeed);
	// TODO: enable
    //Robot::claw->SetClawMotors(clawSpeed);
}

void Arm::ArmPIDSetTestValues(bool def)
{
	prefs = frc::Preferences::GetInstance();
	if (def)
	{
		_armP = ARM_PID_P_VALUE;
		_armI = ARM_PID_I_VALUE;
		_armD = ARM_PID_D_VALUE;

		_intakeP = INTAKE_PID_P_VALUE;
		_intakeI = INTAKE_PID_I_VALUE;
		_intakeD = INTAKE_PID_D_VALUE;

	}
	else
	{
		_armP = prefs->GetDouble("ArmPID P", ARM_PID_P_VALUE);
		_armI = prefs->GetDouble("ArmPID I", ARM_PID_I_VALUE);
		_armD = prefs->GetDouble("ArmPID D", ARM_PID_D_VALUE);

		_intakeP = prefs->GetDouble("IntPID P", INTAKE_PID_P_VALUE);
		_intakeI = prefs->GetDouble("IntPID I", INTAKE_PID_I_VALUE);
		_intakeD = prefs->GetDouble("IntPID D", INTAKE_PID_D_VALUE);
	}
	talonSRX_A1->Config_kP(kPIDLoopIdx, _armP, kTimeoutMs);
	talonSRX_A1->Config_kI(kPIDLoopIdx, _armI, kTimeoutMs);
	talonSRX_A1->Config_kD(kPIDLoopIdx, _armD, kTimeoutMs);
	talonIntake->Config_kP(kPIDLoopIdx, _intakeP, kTimeoutMs);
	talonIntake->Config_kI(kPIDLoopIdx, _intakeI, kTimeoutMs);
	talonIntake->Config_kD(kPIDLoopIdx, _intakeD, kTimeoutMs);
}

void Arm::PrintValues()
{
    frc::SmartDashboard::PutNumber("IntakeTICs", talonIntake->GetSelectedSensorPosition(kPIDLoopIdx));
	frc::SmartDashboard::PutNumber("IntakePID_SetPoint", _intakePIDSetPoint);
	frc::SmartDashboard::PutNumber("IntakeAngle", GetIntakeDegreesFromEnc());
    frc::SmartDashboard::PutNumber("IntakeAMPS", talonIntake->GetOutputCurrent());
    frc::SmartDashboard::PutBoolean("IsIntakeAtSetpoint", _intakeAtPIDPosition);
	frc::SmartDashboard::PutBoolean("IntakePID Active", _intakePIDActive);
	frc::SmartDashboard::PutBoolean("IntakeEnumSet", _intakeEnumSet);
	
	frc::SmartDashboard::PutNumber("Int P", talonIntake->ConfigGetParameter(ParamEnum::eProfileParamSlot_P, 0, 0));
	frc::SmartDashboard::PutNumber("Int I", talonIntake->ConfigGetParameter(ParamEnum::eProfileParamSlot_I, 0, 0));
	frc::SmartDashboard::PutNumber("Int D", talonIntake->ConfigGetParameter(ParamEnum::eProfileParamSlot_D, 0, 0));
	
	frc::SmartDashboard::PutNumber("ArmPosition", talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx));
	frc::SmartDashboard::PutNumber("ArmRevs",     talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx)*ARM_TICS_PER_ROTATION);
	frc::SmartDashboard::PutNumber("ArmAngle",    talonSRX_A1->GetSelectedSensorPosition(kPIDLoopIdx)*ARM_TICS_PER_DEGREE);
	frc::SmartDashboard::PutNumber("ArmVoltage",  talonSRX_A1->GetMotorOutputVoltage());
	frc::SmartDashboard::PutNumber("ArmPWMRaw",   talonSRX_A1->GetSensorCollection().GetPulseWidthPosition());
	frc::SmartDashboard::PutNumber("Arm Set Point",_armPIDSetPoint);
	frc::SmartDashboard::PutNumber("ArmEnum Set", _armEnumSetPoint);
	frc::SmartDashboard::PutNumber("ArmAMPS", talonSRX_A1->GetOutputCurrent());
	frc::SmartDashboard::PutNumber("Arm P", talonSRX_A1->ConfigGetParameter(ParamEnum::eProfileParamSlot_P, 0, 0));
	frc::SmartDashboard::PutNumber("Arm I", talonSRX_A1->ConfigGetParameter(ParamEnum::eProfileParamSlot_I, 0, 0));
	frc::SmartDashboard::PutNumber("Arm D", talonSRX_A1->ConfigGetParameter(ParamEnum::eProfileParamSlot_D, 0, 0));

	//frc::SmartDashboard::PutNumber("IntakePID_P", intakePID->GetP());
	//frc::SmartDashboard::PutNumber("IntakePID_I", intakePID->GetI());
	//frc::SmartDashboard::PutNumber("IntakePID_D", intakePID->GetD());
}

int Arm::GetArmHeightSetting()
{
   E_ARM_POSITION arm = E_ARM_INVALID;
   //bool xboxUsed = false;
   //int xboxShift = Robot::oi->GetXboxBumpL();
   // no shift, buttons score HATCHES
   /*
   if (!xboxShift)
   {
      if (Robot::oi->GetXboxX())
         arm = E_ARM_DOWN;
      else if (Robot::oi->GetXboxA())
         arm = E_ARM_LOAD;
      else if (Robot::oi->GetXboxB())
         arm = E_ARM_MID_HATCH;
      else if (Robot::oi->GetXboxY())
         arm = E_ARM_HIGH_HATCH;
   }
   else
   {
      if      (Robot::oi->GetXboxX())
         arm = E_ARM_CARGO_BALL;
      else if (Robot::oi->GetXboxA())
         arm = E_ARM_LOW_BALL;
      else if (Robot::oi->GetXboxB())
         arm = E_ARM_MID_BALL;
      else if (Robot::oi->GetXboxY())
         arm = E_ARM_HIGH_BALL;
   }

   if (arm != E_ARM_INVALID)
      return (int)arm;
	*/

   if (Robot::oi->getArcadePanel()->GetRawButton(1))
      arm = E_ARM_DOWN;
   else if (Robot::oi->getArcadePanel()->GetRawButton(2))
      arm = E_ARM_LOAD;
   else if (Robot::oi->getArcadePanel()->GetRawButton(3))
      arm = E_ARM_MID_HATCH;
   else if (Robot::oi->getArcadePanel()->GetRawButton(4))
      arm = E_ARM_HIGH_HATCH;
   else if (Robot::oi->getArcadePanel()->GetRawButton(5))
      arm = E_ARM_CARGO_BALL;
   else if (Robot::oi->getArcadePanel()->GetRawButton(6))
      arm = E_ARM_LOW_BALL;
   else if (Robot::oi->getArcadePanel()->GetRawButton(7))
      arm = E_ARM_MID_BALL;
   else if (Robot::oi->getArcadePanel()->GetRawButton(8))
      arm = E_ARM_HIGH_BALL;
   return (int)arm;
}

int Arm::GetIntakeSetting()
{
	E_INTAKE_POSITION intake = E_INTAKE_INVALID;
	/*
	int dpad = Robot::oi->GetXboxDPad();
    switch (dpad)
    {
        case E_DPAD_UP: 
            intake = E_INTAKE_UP;
            break;
        case E_DPAD_RIGHT:
            intake = E_INTAKE_OUT;
            break;
        case E_DPAD_DOWN: 
            intake = E_INTAKE_DOWN;
            break;
    }

	if (intake != E_INTAKE_INVALID)
		return (int)intake;
	*/

	bool buttonUp = Robot::oi->GetIntakeLeverUp();
	bool buttonDown = Robot::oi->GetIntakeLeverDown();
	frc::SmartDashboard::PutBoolean("IntakeLeverUp", buttonUp);
	frc::SmartDashboard::PutBoolean("IntakeLeverDown", buttonDown);
	
	switch (_intakeEnumSet)
	{
		case E_INTAKE_DOWN:
			if (buttonUp)
				intake = E_INTAKE_OUT;
			break;
		case E_INTAKE_OUT:
			if (buttonDown)
				intake = E_INTAKE_DOWN;
			else if (buttonUp)
				intake = E_INTAKE_UP;
			break;
		case E_INTAKE_UP:
			if (buttonDown)
				intake = E_INTAKE_OUT;
			break;
		default:
			intake = E_INTAKE_INVALID;
			break;
	}

	return (int)intake;
}
