// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/StartBNPServer.h"

bool isClient = false;
bool isSetup = false;
int userPort = BN_PORT;
string sesKey;

bool useCompression = false;
int compresionAlg;      //(0 = b64pack, 1 = zstd)

bool useEncryption = false;
int encryptionAlg;      //(0 = nes, 1 = rsa, 2 = aes)

int sockfd = 0, valread; 
int new_socket;
const char *servIP;
char buffer[MAXDATASIZE] = {0};

using namespace std;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

StartBNPServer::StartBNPServer(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::basicNetworkProtocol.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    SetRunWhenDisabled(true);
}// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void StartBNPServer::Initialize() {

}

// Called repeatedly when this Command is scheduled to run
void StartBNPServer::Execute() {

}

// Make this return true when this Command no longer needs to run execute()
bool StartBNPServer::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void StartBNPServer::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void StartBNPServer::Interrupted() {

}

/*****************************************
 * Basic Network Protocol Setup and Recv *
 *****************************************/
int BasicNetworkProtocol::setupServer(){
    int serverfd, new_socket, valread; 
    struct sockaddr_in address; 
    int addrlen = sizeof(address); 
    int opt = 1;
   
    if ((serverfd = socket(BN_AFIP, BN_PROT, 0)) == 0){ 
        perror("socket failed"); 
        exit(EXIT_FAILURE); 
    } 
    
    // Forcefully attaching socket to the port 8080 
    if (setsockopt(serverfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))){ 
        perror("setsockopt"); 
        exit(EXIT_FAILURE); 
    } 
    address.sin_family = BN_AFIP; 
    address.sin_addr.s_addr = INADDR_ANY; 
    address.sin_port = htons(userPort);
    
    // Forcefully attaching socket to the port 8080 
    if (bind(serverfd, (struct sockaddr *)&address, sizeof(address))<0){ 
        perror("bind failed"); 
        exit(EXIT_FAILURE); 
    } 
    
    //Listen for connection
    if (listen(serverfd, 3) < 0){ 
        perror("listen"); 
        exit(EXIT_FAILURE); 
    } 
    
    if ((new_socket = accept(serverfd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0){ 
        perror("accept"); 
        exit(EXIT_FAILURE); 
    } 
    

    
    isSetup = true;
    isClient = false;
    return 0;
    
     
    // printf("%s\n",buffer );
    //send(new_socket , hello , strlen(hello) , 0 ); 
    //printf("Hello message sent\n"); 
    //return 0;
}

int BasicNetworkProtocol::recvData(int sock){
     /* NOTE 
     * Recives data in the format: 
     * PROT_VER(int) useCompression(0/1) compresionAlg(int) useEncryption(0/1) encryptionAlg(int) dataType("double") name("coolNumber") data("420.69")
     * 1 0 0 0 0 double coolNumber 420.69
     * 
     * If compression or encryption is used, the type, name and data will be decrypted first then uncompressed
     */
    stringstream unformatedData;
    int vers;
    bool compresed;
    int compAlg;
    bool encrypted;
    int encryptAlg;
    string rawData;
    string strBuf;
    
    valread = read(sock, buffer, MAXDATASIZE);                              //Get data from network
    unformatedData.str(buffer);                                             //Converts char* to string
    unformatedData >> vers;                                                 //Strips protocol version
    if (vers = 1){
        unformatedData >> compresed >> compAlg >> encrypted >> encryptAlg;  //Strips encryption and compression from data
        unformatedData >> rawData;                                          //Strips type into rawData string
        unformatedData >> strBuf; rawData.append(" "+strBuf);               //Strips name into rawData string
        unformatedData >> strBuf; rawData.append(" "+strBuf);               //Strips data into rawData string
    }
    
    if(encrypted){
        rawData = decrypt(rawData, encryptionAlg);                      //Decrypts if encrypted
    }
    
    if(compresed){
        rawData = uncompress(rawData, encryptionAlg);                   //Uncompresses if compressed
    }
    
    putData(rawData);                                                   //Runs putData() so data can be indexed
    return 0;
}

int BasicNetworkProtocol::putData(string data){
    return 0;
}


/*
 * Compresion and encryption support            TODO
 */
int BasicNetworkProtocol::compressData(int alg, bool enable){
    if(!enable){
        useCompression = 0;
        return 0;
    }
    if(useCompression){
        if(alg == compresionAlg){
            return 0;
        }
    }
   
    useCompression = true;
    compresionAlg = alg;
    return 0;
}

string BasicNetworkProtocol::compress(string data, int compresionAlg){
    //char *foo;
    //size_t foolen = get_message(&foo);
    //b64pack_compress(foo, &foolen);
    
    string compressedData;
    return compressedData;
}

string BasicNetworkProtocol::uncompress(string compressedData, int compresionAlg){
    string data;
    return data;
}

int BasicNetworkProtocol::encryptData(int alg, bool enable){
    if(!enable){
        useEncryption = 0;
        return 0;
    }
    if(useEncryption){
        if(alg == encryptionAlg){
            return 0;
        }
    }
   
    useEncryption = true;
    encryptionAlg = alg;
    return 0;
}

string BasicNetworkProtocol::encrypt(string data, int encryptionAlg){
    string encryptedData;
    return encryptedData;
}

string BasicNetworkProtocol::decrypt(string encryptedData, int encryptionAlg){
    string data;
    return data;
}