// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


//Progress -> Full Automation   %57
//Progress -> Lock On           %45

//Determine Angle From NetworkTables                            0
//Determine Distance from Rocket                                #
//Create System to turn to angle                                #
//Create System to get exact location of Rocket                 0
//Create System to compute trajectory                           #
//Create System to drive in trajectory                          #
//Refine/Streamline/Complete                                    0




#include "Commands/LockOnAndApproachGoal.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

LockOnAndApproachGoal::LockOnAndApproachGoal(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void LockOnAndApproachGoal::Initialize() {
    currentAngle = Robot::driveTrain->GetGyroBearing();
    GetNetworkTable();
    GetTargetLocation();
    GetTargetAngle();
    if(useTrajectorySys){
        DetermineTrajectory();
    }

}

// Called repeatedly when this Command is scheduled to run
void LockOnAndApproachGoal::Execute() {
    if(useTrajectorySys){
        GotoRocket();
    }
    else{
       TurnToAngle();
    }

}

// Make this return true when this Command no longer needs to run execute()
bool LockOnAndApproachGoal::IsFinished() {
    return (std::abs(t_error) < ErrorThreshold) || IsTimedOut();
}

// Called once after isFinished returns true
void LockOnAndApproachGoal::End() {
    Robot::driveTrain->Stop();

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void LockOnAndApproachGoal::Interrupted() {

}



void LockOnAndApproachGoal::GetTargetAngle(){
    


    //do stuff

    double targetAngle = 15.0;      //Dummy Value just for testing

}

void LockOnAndApproachGoal::GetNetworkTable(){
    table = NetworkTable::GetTable("JETSON/myContoursReport");
}

void LockOnAndApproachGoal::TurnToAngle(){
    //Difference between target and current angle
    t_error = currentAngle - targetAngle;

    //Determin speed to turn robot
    double spinRate = ((t_error < 0.0) ? SpinMagnatude : -1.0 * SpinMagnatude);

    //Turn Robot
    Robot::driveTrain->RotateRobot(spinRate);
}

void LockOnAndApproachGoal::GetTargetLocation(){
    //This currently only gets location of rocket from jetson, not reletive to the robot!

    std::vector<double> t_centerX = table->GetNumberArray("centerX", llvm::ArrayRef<double>());
    std::vector<double> t_centerY = table->GetNumberArray("centerY", llvm::ArrayRef<double>());

    centerX = t_centerX[1] - t_centerX[0];
    centerY = t_centerY[1] - t_centerY[0];

    centerX = centerX + VisionOffset;

    double cRocketLocation [] = {centerX, centerY};   //Rocket location relative to the jetson camera data

/////////////////////////////////////////////////////////////New Code//////////////////////////////////////////

    double distFromRocket = ConvertToDouble(Robot::arduino->GetDistanceSensor());

    double realX = sin(targetAngle)*distFromRocket;       //Determine X relative to the robot (needs provisions for left angle!!)
    double realY = cos(targetAngle)*distFromRocket;       //Determine Y relative to the robot (needs provisions for left angle!!)
    
    double rocketLocation[] = {realX, realY};

}

double LockOnAndApproachGoal::ConvertToDouble(uint32_t dist1){
    double dist2 = (double)dist1; //Convert to sensor unsigned int to double
    return dist2;
}



void LockOnAndApproachGoal::DetermineTrajectory(){
    //This will determine the circular trajectory of the robot to the rocket
    //This may be moved to the jetson to relive computational strain

    //This code is also a horribly written mess because I don't know how to use
    //Math functions and was to0  lazy to figure out how to.

    //based of TIGINOMETRY calculations from https://goo.gl/cEFDn2
    //There seems to be a much easier method using calculus https://goo.gl/KDNERX However I have slightly less trust in this

    //THYT = θ DO NOT DIRECTLY USE θ!!! It breaks all of this code!!!


    if(!useCalc){
        //Determine trajectory with TRIGONOMETRY
        double x0 = 0.0;                    //Initial X
        double y0 = 0.0;                    //Intital Y
        double THYT0 = currentAngle;        //Initial rotation
        double s = trajSpd;                 //Speed
        double rg;                          //Polar coordinate based on range to goal       --NEEDS ASIGNED 
        double THYTg;                       //Polar coordinate based on bearing to goal     --NEEDS ASIGNED
        double x1 = rocketLocation[0];      //Target X
        double y1 = rocketLocation[1];      //Target Y

        double t;                           //Time
        double t0 = 0.0;                    //Initial Time
        double t1;                          //Computed Final Time

        double THYT = 2*THYTg;              //computed angle/s (also difference in angle from start to finish)
        double rc = (rg/2*sin(THYTg));      //Radius of circle
        double xc = x0-rc*sin(THYT0);       //Center X of circle
        double yc = y0+rc*cos(THYT0);       //Center Y of circle
        double l = rc*THYT;                 //Lengh of arc traveled by robot;

        double v = THYT/(l/s);                                       //Computed anglular velocity (Rad/Sec)
        double THYT_t = v*(t-t0)+THYT0;                              //Angle as a function of time
        double x = x0-rc*sin(THYT0)+rc*sin(v*(t-t0)+THYT0);          //X(t) position of robot as a function of time
        double y = y0+rc*cos(THYT0)-rc*cos(v*(t-t0)+THYT0);          //Y(t) postition of robot as a function of time 

        double trajectory[] = {x0, y0, THYT_t, x, y};
    }
    else{
        //Determine trajectory with CALCULUS
        double x0 = 0.0;                     //Initial X
        double y0 = 0.0;                     //Initial Y
        double THYT0 = currentAngle;         //Initial Angle
        double t;                            //Time
        double t0 = 0.0;                     //Initial Time
        double s = trajSpd;                  //Speed

        double v;                            //Calculated Angular Velocity (Rad/Sec);
        double THYT = v*(t-t0)+THYT0;        //Angle as a function of time
        double rc = (s/v);

        double x = x0 -rc*sin(THYT0)+rc*sin(v*(t-t0)+THYT0);                           //X(t) position of robot as a function of time
        double y = y0 +rc*sin(THYT0)-rc*sin(v*(t-t0)+THYT0);                           //Y(t) postition of robot as a function of time 

        double trajectory[] = {x0, y0, THYT, x, y};
    }

}

void LockOnAndApproachGoal::GotoRocket(){
    double xdif = abs(rocketLocation[0] - trajectory[3]);
    double ydif = abs(rocketLocation[1] - trajectory[4]);

    auto start_time = std::chrono::steady_clock::now();

    while(xdif>4  && ydif>4){
        auto current_time = std::chrono::steady_clock::now();
        double rotaion = trajectory[2]*std::chrono::duration_cast<std::chrono::seconds>(current_time-start_time).count();

        Robot::driveTrain->ArcadeDrive(trajSpd, rotaion);
    }
    
    Robot::driveTrain->Stop();

}